---
description: Sample instructions for logging and monitoring access token usage
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# How To: Client Access Token Monitoring

## Overview

This guide describes how to implement monitoring for client access tokens in the Ed-Fi ODS/API. By tracking token usage, administrators can enhance security monitoring, detect unusual access patterns, and maintain audit trails for compliance purposes.

## Use Case

The Ed-Fi ODS/API's `EdFi_Admin` database manages API client access through a hierarchical structure:

- **Vendors** contain multiple **Applications**
- **Applications** contain multiple **API Clients**
- **API Clients** have associated **Client Access Tokens**

Each successful client authentication request generates a client access token in the `dbo.clientaccesstokens` table. Monitoring the usage of these tokens is valuable for security and operational insights. However, monitoring was not included out-of-the-box in the Ed-Fi ODS/API. Without additional logging, it's difficult to:

- Track when and how frequently tokens are being used.
- Identify potentially compromised tokens showing unusual access patterns.
- Maintain audit logs for security compliance.
- Analyze usage patterns for capacity planning.

## Security Benefits

Implementing client access token monitoring provides several security advantages:

:::tip Security Benefits

- **Anomaly Detection**: Identify tokens being accessed at unusual times or frequencies.
- **Audit Trail**: Maintain comprehensive logs for compliance and forensic analysis.
- **Breach Detection**: Quickly identify if tokens are being used from unexpected sources.
- **Usage Analytics**: Monitor API usage patterns to detect potential abuse.
- **Token Lifecycle Management**: Track token usage to determine when tokens should be rotated.

:::

## Implementation

### Step 1: Create Access Log Table

First, create a table to store access log entries:

  <Tabs>
    <TabItem value="MSSQL" label="SQL Server" default>
    ```sql
    CREATE TABLE dbo.ClientAccessTokenLogs
    (
      LogId BIGINT IDENTITY(1,1) NOT NULL PRIMARY KEY,
      TokenId UNIQUEIDENTIFIER NOT NULL,
      AccessTime DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
      ApiClientId INT NOT NULL,
      client_id VARCHAR(50) NOT NULL,
      ApplicationId INT NOT NULL,
      ApplicationName NVARCHAR(MAX) NOT NULL,
      VendorId INT NOT NULL,
      VendorName NVARCHAR(MAX) NOT NULL
    );

    CREATE INDEX idx_clientaccesstoken_logs_access_time
    ON dbo.ClientAccessTokenLogs (AccessTime);
    ```
    </TabItem>
    <TabItem value="PostgreSQL" label="PostgreSQL">
    ```sql
    CREATE TABLE IF NOT EXISTS dbo.clientaccesstoken_logs
    (
        logid bigserial NOT NULL,
        token_id uuid NOT NULL,
        access_time timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
        apiclient_id integer NOT NULL,
        client_id varchar(50) NOT NULL,
        application_id integer NOT NULL,
        application_name varchar NOT NULL,
        vendor_id integer NOT NULL,
        vendor_name varchar NOT NULL,
        CONSTRAINT clientaccesstoken_logs_pk PRIMARY KEY (logid)
    );

    CREATE INDEX IF NOT EXISTS idx_clientaccesstoken_logs_access_time
    ON dbo.clientaccesstoken_logs (access_time);
    ```
    </TabItem>
  </Tabs>

### Step 2: Create Logging Trigger

Next, create a function to log token access:

<Tabs>
  <TabItem value="MSSQL" label="SQL Server" default>
  ```sql
  CREATE TRIGGER trg_LogClientAccessTokenInsert
  ON dbo.clientaccesstokens
  AFTER INSERT
  AS
  BEGIN
    SET NOCOUNT ON;

    INSERT INTO dbo.ClientAccessTokenLogs (
      TokenId,
      AccessTime,
      ApiClientId,
      client_id,
      ApplicationId,
      ApplicationName,
      VendorId,
      VendorName
    )
    SELECT
      i.Id,
      SYSUTCDATETIME(),
      i.ApiClient_ApiClientId,
      ac.[Key] AS client_id,
      app.ApplicationId,
      app.ApplicationName,
      v.VendorId,
      v.VendorName
    FROM
      inserted i
      INNER JOIN dbo.ApiClients ac ON i.ApiClient_ApiClientId = ac.ApiClientId
      INNER JOIN dbo.Applications app ON ac.Application_ApplicationId = app.ApplicationId
      INNER JOIN dbo.Vendors v ON app.Vendor_VendorId = v.VendorId;
  END
  GO
  ```
  </TabItem>
  <TabItem value="PostgreSQL" label="PostgreSQL">
  ```sql
  CREATE OR REPLACE FUNCTION dbo.log_token_access()
  RETURNS TRIGGER AS $$
  BEGIN
      IF TG_OP = 'INSERT' THEN
          INSERT INTO dbo.clientaccesstoken_logs (
            token_id,
            access_time,
            apiclient_id,
            client_id,
            application_id,
            application_name,
            vendor_id,
            vendor_name
          )
          SELECT
            NEW.id,
            CURRENT_TIMESTAMP,
            NEW.apiclient_apiclientid,
            apiclients.key as client_id,
            applications.applicationid,
            applications.applicationname,
            vendors.vendorid,
            vendors.vendorname
          FROM
            dbo.apiclients
          INNER JOIN
            dbo.applications on apiclients.application_applicationid = applications.applicationid
          INNER JOIN
            dbo.vendors on applications.vendor_vendorid = vendors.vendorid
          WHERE
            apiclients.apiclientid = NEW.apiclient_apiclientid;
      END IF;

      RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;


  CREATE TRIGGER trigger_log_token_access
      AFTER INSERT ON dbo.clientaccesstokens
      FOR EACH ROW
      EXECUTE FUNCTION dbo.log_token_access();
  ```
  </TabItem>
</Tabs>

## Monitoring Queries

### Basic Access Log Query

Retrieve access logs with client, application, and vendor information:


<Tabs>
  <TabItem value="MSSQL" label="SQL Server" default>
  ```sql
  SELECT *
  FROM dbo.ClientAccessTokenLogs
  ORDER BY VendorName, ApplicationName, AccessTime ASC
  ```
  </TabItem>
  <TabItem value="PostgreSQL" label="PostgreSQL">
  ```sql
  SELECT *
  FROM dbo.clientaccesstoken_logs
  ORDER BY vendor_name, application_name, access_time ASC
  ```
  </TabItem>
</Tabs>

### Recent Activity by Vendor

Monitor recent token activity grouped by vendor:

<Tabs>
  <TabItem value="MSSQL" label="SQL Server" default>
  ```sql
  SELECT
    VendorName,
    COUNT(*) AS AccessCount,
    MAX(AccessTime) AS LastAccess,
    COUNT(DISTINCT TokenId) AS UniqueTokens
  FROM dbo.ClientAccessTokenLogs
  WHERE AccessTime >= DATEADD(day, -1, SYSUTCDATETIME())
  GROUP BY VendorName
  ORDER BY AccessCount DESC;
  ```
  </TabItem>
  <TabItem value="PostgreSQL" label="PostgreSQL">
  ```sql
  SELECT
      vendor_name,
      COUNT(*) AS access_count,
      MAX(access_time) AS last_access,
      COUNT(DISTINCT token_id) AS unique_tokens
  FROM dbo.clientaccesstoken_logs
  WHERE access_time >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
  GROUP BY vendor_name
  ORDER BY access_count DESC;
  ```
  </TabItem>
</Tabs>

### Suspicious Activity Detection

Identify tokens with unusually high access frequency:

<Tabs>
  <TabItem value="MSSQL" label="SQL Server" default>
  ```sql
  SELECT
      client_id,
      ApplicationName,
      VendorName,
      COUNT(*) AS AccessCount,
      MIN(AccessTime) AS FirstAccess,
      MAX(AccessTime) AS LastAccess
  FROM dbo.ClientAccessTokenLogs
  WHERE AccessTime >= DATEADD(day, -1, SYSUTCDATETIME())
  GROUP BY client_id, ApplicationName, VendorName
  HAVING COUNT(*) > 100  -- Adjust threshold as needed
  ORDER BY AccessCount DESC;
  ```
  </TabItem>
  <TabItem value="PostgreSQL" label="PostgreSQL">
  ```sql
  SELECT
  client_id,
      application_name,
      vendor_name,
      COUNT(*) AS access_count,
      MIN(access_time) AS first_access,
      MAX(access_time) AS last_access
  FROM dbo.clientaccesstoken_logs
  WHERE access_time >= CURRENT_TIMESTAMP - INTERVAL '1 hour'
  GROUP BY client_id, application_name, vendor_name
  HAVING COUNT(*) > 100  -- Adjust threshold as needed
  ORDER BY access_count DESC;
  ```
  </TabItem>
</Tabs>

### Token Usage Timeline

Analyze token usage patterns over time:

<Tabs>
  <TabItem value="MSSQL" label="SQL Server" default>
  ```sql
  SELECT
    DATEADD(hour, DATEPART(hour, AccessTime), CAST(CAST(AccessTime AS date) AS datetime)) AS AccessHour,
    VendorName,
    ApplicationName,
    client_id,
    COUNT(*) AS access_count
  FROM dbo.ClientAccessTokenLogs
  WHERE AccessTime >= DATEADD(day, -7, SYSUTCDATETIME())
  GROUP BY DATEADD(hour, DATEPART(hour, AccessTime), CAST(CAST(AccessTime AS date) AS datetime)), VendorName, ApplicationName, client_id
  ORDER BY AccessHour DESC, access_count DESC;
  ```
  </TabItem>
  <TabItem value="PostgreSQL" label="PostgreSQL">
  ```sql
  SELECT
      DATE_TRUNC('hour', access_time) AS access_hour,
      vendor_name,
  application_name,
  client_id,
      COUNT(*) AS access_count
  FROM dbo.clientaccesstoken_logs
  WHERE access_time >= CURRENT_TIMESTAMP - INTERVAL '7 days'
  GROUP BY DATE_TRUNC('hour', access_time), vendor_name, application_name, client_id
  ORDER BY access_hour DESC, access_count DESC;
  ```
  </TabItem>
</Tabs>


## Maintenance

### Log Retention

To prevent the log table from growing indefinitely, implement a retention policy:

<Tabs>
  <TabItem value="MSSQL" label="SQL Server" default>
  ```sql
  -- Delete logs older than 90 days
  DELETE FROM dbo.ClientAccessTokenLogs
  WHERE AccessTime < DATEADD(day, -90, SYSUTCDATETIME());
  ```
  </TabItem>
  <TabItem value="PostgreSQL" label="PostgreSQL">
  ```sql
  -- Delete logs older than 90 days
  DELETE FROM dbo.clientaccesstoken_logs
  WHERE access_time < CURRENT_TIMESTAMP - INTERVAL '90 days';
  ```

  </TabItem>
  </Tabs>

Consider setting up a scheduled job to run this cleanup query regularly.

### Performance Monitoring

Monitor the performance impact of the logging:

<Tabs>
  <TabItem value="MSSQL" label="SQL Server" default>
  ```sql
  -- Check log table size
  EXEC sp_spaceused 'dbo.ClientAccessTokenLogs';

  -- Check index fragmentation
  SELECT
      dbschemas.[name] as 'Schema',
      dbtables.[name] as 'Table',
      dbindexes.[name] as 'Index',
      indexstats.avg_fragmentation_in_percent
  FROM sys.dm_db_index_physical_stats (DB_ID(), OBJECT_ID('dbo.ClientAccessTokenLogs'), NULL, NULL, 'LIMITED') AS indexstats
  INNER JOIN sys.tables dbtables on dbtables.[object_id] = indexstats.[object_id]
  INNER JOIN sys.schemas dbschemas on dbtables.[schema_id] = dbschemas.[schema_id]
  INNER JOIN sys.indexes AS dbindexes ON dbindexes.[object_id] = indexstats.[object_id]
      AND indexstats.index_id = dbindexes.index_id
  WHERE dbtables.[name] = 'ClientAccessTokenLogs';

  -- Check trigger performance impact (review recent trigger execution time)
  SELECT
      t.name AS TriggerName,
      te.execution_count,
      te.total_elapsed_time / 1000.0 AS TotalElapsedSeconds,
      te.total_worker_time / 1000.0 AS TotalWorkerSeconds
  FROM sys.triggers t
  LEFT JOIN sys.dm_exec_trigger_stats te ON t.object_id = te.object_id
  WHERE t.name = 'trg_LogClientAccessTokenInsert';
  ```
  </TabItem>
  <TabItem value="PostgreSQL" label="PostgreSQL">
  ```sql
  -- Check log table size
  SELECT
      schemaname,
      tablename,
      attname,
      n_distinct,
      correlation
  FROM pg_stats
  WHERE tablename = 'clientaccesstoken_logs';

  -- Check trigger performance impact
  SELECT * FROM pg_stat_user_tables WHERE relname = 'clientaccesstoken_logs';
  ```
  </TabItem>
</Tabs>

## Best Practices

:::tip Recommendations

1. **Regular Monitoring**: Review access logs daily for unusual patterns
2. **Alerting**: Set up automated alerts for suspicious activity thresholds
3. **Data Retention**: Establish appropriate log retention policies based on compliance requirements
4. **Index Maintenance**: Regularly analyze and optimize database indexes for query performance
5. **Security Review**: Periodically review and update monitoring queries based on emerging threats

:::

## Troubleshooting

### Common Issues

#### Trigger Not Firing

- Verify the trigger is enabled:

  <Tabs>
    <TabItem value="MSSQL" label="SQL Server" default>
    ```sql
    SELECT name, is_disabled FROM sys.triggers WHERE name = 'trg_LogClientAccessTokenInsert';
    ```
    </TabItem>
    <TabItem value="PostgreSQL" label="PostgreSQL">
    ```sql
    SELECT * FROM pg_trigger WHERE tgname = 'trigger_log_token_access';
    ```
    </TabItem>
  </Tabs>

- Check for trigger errors in database server logs

#### Performance Impact

- Monitor query execution times before and after implementation
- Consider adjusting logging frequency if performance degradation occurs

#### Missing Log Entries

- Verify that token usage actually updates the expiration timestamp
- Consider modifying the trigger logic to capture other usage indicators

## Conclusion

Implementing client access token monitoring provides essential visibility into API usage patterns and enhances the security posture of your Ed-Fi implementation. Regular analysis of the collected data helps maintain system security and supports compliance requirements.
